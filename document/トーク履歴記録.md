はい、ここで言う **「メッセージ」** というのは **ボットが参加している LINE グループ／LINE 1:1 トーク／Slack チャンネル／Teams チャット・チャネル** などで実際にやり取りされるチャット投稿そのものを指しています。もう少し細かく分けると、プラットフォームごとに次のように扱います。

| プラットフォーム | どの単位で “メッセージ” を受信・保存する？                               | セッションを識別するキー                                                                                                       |
| ---------------- | ------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| **LINE**         | - 1:1 トーク<br>- グループ<br>- ルーム（複数人トーク）                   | `platform=line` + `sourceId`（ユーザー ID / グループ ID / ルーム ID）+ `threadId`（固定値…LINE はスレッド概念がないので null） |
| **Slack**        | - チャンネルメッセージ（public / private）<br>- DM / グループ DM         | `platform=slack` + `channelId` + `threadTs`（スレッド返信の場合は thread\_ts、通常は message\_ts）                             |
| **Teams**        | - チャネル投稿（Team ➜ Channel）<br>- グループチャット<br>- 1:1 チャット | `platform=teams` + `conversationId` + `threadId`（reply chain ID）                                                             |

### 具体的な流れ

1. **ボットがメンバー** になっている部屋・チャネルにメッセージが投稿される
2. プラットフォームが Webhook で **イベント**（テキスト・送信者・タイムスタンプなど）を送ってくる
3. ChatRouter Lambda がイベントを正規化し、

   * どの「会話（session）」に属するかをキーで判断
   * `SessionLog` テーブルに 1 行として保存（text, sender, ts, vector 等）
4. `/ask` が来た場合は、その **同じ会話キー** をもとにヒアリング／調査を進める

> 🔸 **グループ内で bot が @メンション された発言だけを対象** にするか、すべての発言を対象にするかは設定次第です。ノイズ防止のため、初期設定では “bot が呼ばれたメッセージ” だけログに残す形がオススメです。

### 収納されるデータのイメージ（DynamoDB アイテム）

```jsonc
{
  "PK": "session#line#C4x789",   // 例: LINE グループ
  "SK": "ts#1721212121212",
  "text": "Podman で BuildKit を有効にする方法は？",
  "sender": "Uabc123",
  "vector": [0.123, ...],        // MiniLM 768 次元
  "source_meta": {
    "platform": "line",
    "groupId": "C4x789",
    "threadId": null
  }
}
```

このように「どのチャネルで、誰が、いつ送ったか」を一意に切り分けたうえで保存するので、**LINE のグループ／Teams のチャット** などプラットフォームが違っても同じロジックで “前後の会話” を取ってこられます👍
